第九章学习笔记
===
类
===
##### Python具有面对对象编程的特性，在面对对象编程中，我们可以编写“类”，定义一大类对象都有的通用行为。这种根据类来创建对象的操作被称作“实例化”
9.1创建实例
---
类可以用来模拟现实生活中存在的事物，下面举一个例子，编写一个表示小狗的实例<br>
> 主要流程有两步，创建Dog类、根据类创建实例<br>
### 1.创建Dog类
```
class Dog():
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def sit(self):
        print(self.name.title() + " is now sitting!")
    def roll_over():
        print(self.name.title() + " rolled over!")
```
* (1)这次创建类时，类定义中括号应该是空的，因为我们要从空白创建这个类<br>
* (2)类中的函数被称作方法，第一个函数__init__(self,...)是一个特殊的方法，在python中创建新实例时，都会自动运行它，要注意的是，在init的前后各有两个下划线
* (3)在这个例子中，__init__(定义包括了三个形参，要注意的是，形参self必不可少，而且还得在其他形参前面。形参self是一个指向实例本身的引用，让实例能够访问类中的属性与方法
* (4)在创建实例时只需要给除self外的两个形参赋值即可
* (5)__init__(中定义的两个变量前都必须有前缀self，以self为前缀的变量可供类中的所有方法使用，这种变量被称作“属性”
* (6)后两个方法sit()和roll_over()负责打印消息，指出小狗在下蹲或打滚
### 2.根据Dog类创建实例
```
my_dog = Dog('bvb', 6)
print("My dog's name is " + my_dog.name.title() + ".")
print("The age of my dog is " + str(my_dog.age) + " year's old.")
my_dog.sit()
my_dog.roll_over()
```
这段程序首先创建一条名字为"bvb"，年龄为6岁的小狗，然后将它的名字和年龄打印出来，最后调用类中的方法，实现下蹲和打滚<br>
* (1)方法__init__()未包含return语句，但是在运行时，python将自动返回一个表示这是条小狗的实例
* (2)注意命名规定，一般认为首字母大写的名称是类(如Dog)，小写的名称是根据类创造的实例(如my_dog)
* (3)访问实例的属性非常简单，同上一章引用模块中的函数，利用句号表示法即可。调用类中的方法也是同样的方法

> 可按照需求根据类来创建任意数量的实例<br>

9.2使用类和实例
===
在创造类和实例之后，我们需要使用这些根据类创建的实例来完成一些操作，例如修改实例的属性
```
class Car():
    def __init__(self, mark, model, year):
        self.mark = mark
        self.model = model
        self.year = year
    def get_descriptive_name(self):
        long_name = str(self.year) + ' ' + self.mark + ' ' + self.model
        return long_name.title()
my_new_car = Car('audi', 'a4', 2020)
print("My new car is " + my_new_car.get_descriptive_name())
```
首先创建一个关于汽车的类，它包括了车品牌、型号、年份信息，在根据类创建实例时也需要指定这三个信息<br>
类中还包括了一个方法get_descriptive_name(，它通过访问类属性来进行组合，让我们无需分别打印各个属性即可完整打印汽车的信息<br>
> 接下来我们来对这个类进行操作，包括：给属性指定默认值、修改属性的值(三种方法)<br>
### 1.给属性默认值<br>
类中每个实例在创建实例时都必须有初始值，是0或者空字符串也可以。<br>
在__init__()之中我们就可以给某个属性赋予初始值，我们就无需给它提供初始值的形参。<br>
```
class Car():
    def __init__(self, mark, model, year):
        self.mark = mark
        self.model = model
        self.year = year
        self.odometer_reading = 0
    def get_descriptive_name(self):
        long_name = str(self.year) + ' ' + self.mark + ' ' + self.model
        return long_name.title()
    def read_odometer(self):
        print("This car has " + str(self.odometer_reading) + " miles on it.")
my_new_car = Car('audi', 'a4', 2020)
print("My new car is " + my_new_car.get_descriptive_name())
my_new_car.read_odometer()
```
在init方法之中我们设定了一个新的属性 odometer_reading ，代表汽车行驶里程数，并给它赋初始值为0。<br>
还设定了一个新方法 read_odometer 来方便地获取汽车的行驶情况。
> 接下来我们要根据汽车的实际行驶情况对属性 odometer_reading 进行修改<br>
### 2.修改属性的值(直接修改法)<br>
最简单的方法就是直接通过实例访问该属性，并修改
```
class Car():
    同上
my_new_car = Car('audi', 'a4', 2020)
my_new_car.odometer_reading = 23
my_new_car.read_odometer()
```
* (1)直接利用句号表示法来访问 odometer_reading 属性，并进行修改
* (2)大多情况下需要使用其他方法来对该属性进行更新
### 3.修改属性的值(方法修改法)<br>
增加代替我们来更新属性的方法
```
class Car():
    同上
    def update_odometer(self, mileage):
        self.odometer_reading = mileage
my_new_car = Car('audi', 'a4', 2020)
my_new_car.update_odometer(23)
my_new_car.read_odometer()
```
增添了一个方法 update_odometer( 来对属性 odometer_reading 进行更新
* (1)无需直接访问属性，将值传递给一个方法，在类的内部进行更新
* (2)可以对这个方法进行扩展，比如说禁止任何人将里程回调
### 3.修改属性的值(方法递增法)<br>
有时候我们无需将属性设定为全新的值，仅需要将属性值递增一定的量
```
class Car():
    同上
    def increment_odometer(self, miles):
        self.odometer_reading += miles
my_new_car = Car('audi', 'a4', 2020)
my_new_car.update_odometer(23000)
my_new_car.increment_odometer(100)
my_new_car.read_odometer()
```
假设我们购买了一辆二手车，其已经行驶了23000公里，在驾驶她去车管所登记的过程中行驶了100公里，我们就需要在原来23000公里的基础上增加。
* (1)新增了方法 increment_odometer() 来接收一个代表新增公里数的实参，将它的值加到 odometer_reading 上
* (2)同样可以对这个方法进行扩展，例如禁止任何人将里程回调