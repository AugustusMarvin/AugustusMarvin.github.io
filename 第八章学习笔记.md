第八章学习笔记
===

8.1定义函数的方法
---
```
def 函数名(信息):
    函数内容
```
* 1.注意函数名应当尽量的简洁，且能直观地表述函数作用。<br>
* 2.函数名后的括号中指出函数为完成其任务需要哪些信息。<br>
* 3.要调用函数时，需要以此指定函数名，并在括号中填入必要的信息。<br>


8.2形参以及实参
---
如下，先给出一个实例<br>
```
def greet_user_1(username):
    print("\nBonjour! " + username.title() + ".")
greet_user_1("marvin")
```
* 1.在定义过程中，函数名后括号中的"username"就是一个典型的形参，定义为完成其任务需要的信息。<br>
* 2.在函数被调用时，greet_user_1("marvin")，其中"marvin"就是一个典型的实参，定义为调用函数时传递给函数的信息。<br>
* 3.调用时，我们先将函数使用的信息放在括号之中，然后将实参传递给了被调用的函数，而实参的值被存储于形参之中。<br>


8.3传递实参
---
函数定义时可能包括了多个形参，所以调用的过程中可能包括多个实参。<br>

1.最简单的关联方式为“位置实参”，它是基于实参的顺序。<br>
    以下给出一个实例<br>
```
    def describe_pet(animal_type, pet_name):
        print("\nI have a " + animal_type.title() + ".")
        print("My " + animal_type.title() + "'s name is " + pet_name.title() + ".")
    describe_pet("dog", "dortmund")
    describe_pet("cat", "bayern")
```
* (1)调用函数describe_pet时，按顺序提供一种动物类型和一个名字，动物类型被存储于形参animal_type之中，而动物名字被存储于pet_name之中。<br>
* (2)想要再次调用函数时，只需要重新输入新的动物类型与名字。<br>
* (3)在位置实参之中，我们需要时刻注意实参的顺序。<br>

2.另外一种方法是“关键字实参”，这种方式定义函数的方式没有变化，主要特点是在调用过程中，它传递给函数名称-值对，直接在实参之中将名称和值相关联，所以调用函数传递实参时不会混淆，无需考虑实参的顺序。<br>
    以下给出一个关键字实参的调用实例，函数同上一个函数<br>
```
    describe_pet_1(animal_type='hamster', pet_name='paris')
    describe_pet_1(pet_name='Madrid', animal_type='sheep')
```
以上两个调试结果如下
```
    I have a Hamster.
    My Hamster's name is Paris.

    I have a Sheep.
    My Sheep's name is Madrid.
```
可以明显的看出，即便我们调换了实参的顺序，但是最后的输出结果顺序是正确的。<br>
* (1)需要注意的是，使用关键字实参时，需要准确地指出函数定义中的形参名<br>

3.还有一种方法是“默认值”，它在定义函数时给形参指定了默认值，若在调用函数时未指定实参值，python将会自动使用默认的实参值。这种方法可以在函数调用时省略相应的实参。<br>
    以下为默认值的实例<br>
```
    def describe_pet_2(pet_name, animal_type='dog'):
        print("\nI have a " + animal_type.title() + ".")
        print("My " + animal_type.title() + "'s name is " + pet_name.title() + ".")
    describe_pet_2(pet_name='Man')
    describe_pet_2('Che')
    describe_pet_2('Liv', 'tiger')
    describe_pet_2(animal_type='tiger', pet_name='Liv')
```
* (1)在输出时默认形参animal_type的默认值为"dog"，调用时若未指定这个形参值，输出都为dog。<br>
* (2)describe_pet_2('Che')是describe_pet_2(pet_name='Man')的简化写法。<br>
* (3)在定义函数时，括号中的形参列表应当先列出无默认值的形参，再列出有默认值的实参，否则会报错<br>
* (4)若描述对象不是dog，依旧可以通过位置实参来进行传递，如describe_pet_2('Liv', 'tiger')，
            同理，我们也依旧可以使用关键字方式来传递，如describe_pet_2(animal_type='tiger', pet_name='Liv')<br>


8.4返回值
---
函数可以处理一些数据，并返回一个或者多个值，为返回值
函数可以返回任何类型的值，包括字典 列表<br>
一般我们使用return语句来实现<br>

1.我们还可以利用默认值的方法来让实参变得可选，如下<br>
```
    def get_formatted_name_1(first_name, last_name, middle_name=''):
        if middle_name:
            full_name = first_name.title() + ' ' + middle_name.title() + ' ' + last_name.title()
        else:
            full_name = first_name.title() + ' ' + last_name.title()
        return full_name
    musician = get_formatted_name_1('jimi', 'hendrix')
    print(musician)
    musician = get_formatted_name_1('john', 'hooker', 'lee')
    print(musician)
```
需要确保可选的部分为最后一个实参，这样才能正确地位置关联<br>

2.返回的也可以是一个字典，如下<br>
```
    def build_person(first_name, last_name):
        person = {'first':first_name.title(), 'last':last_name.title()}
        return person
    musician = build_person('jimi', 'hendrix')
    print("\nMy favorite musician is " + musician['first'] + " " + musician['last'])
```
8.5传递列表
---
列表可能包含，数字、名字以及字典等复杂对象，列表传递给函数之后，函数可以直接访问其内容，提高程序运行效率。<br>
以下为一个实例
```
    def greet_users(names):
        for name in names:
            msg = "Hello, " + name.title() + "!"
            print(msg)
    usernames = ['marvin', 'lea', 'leo', 'jan']
    greet_users(usernames)
```
首先将函数定义为接受名字列表，在调用函数时，实参列表usernames传递给了形参names。<br>
我们还可以实现其他操作，如在函数中修改列表、使用副本以禁止函数修改列表<br>

1.函数中修改列表
将列表传递给函数之后，函数就可以对列表进行修改。<br>
实例如下<br>
```
    unprinted_designs = ['iphone case', 'robot pendant', 'dodecahedron']
    completed_models = []
    def print_models(unprinted_designs, completed_models):
        while unprinted_designs:
            current_design = unprinted_designs.pop()
            print("Printing model: " + current_design.title())
            completed_models.append(current_design)
    def show_completed_models(completed_models):
        for completed_model in completed_models:
            print(completed_model.title())
    print_models(unprinted_designs, completed_models)
    show_completed_models(completed_models)
```
首先将需要打印的文字储存在一个列表之中，打印之后转移到另外一个列表中。<br>
* (1)值得注意的是，在函数中，对这个列表所做的任何修改都是永久性的
* (2)在这段程序之中使用了两个模块化的程序，这种模块化编程更加直观，并且能够提高运行效率
* (3)第一个函数目的是打印每个设计，并在打印后将其移动至列表completed_models中。这个函数使用了两个形参，unprinted_designs是未打印的列表，completed_models是已经打印的列表，在函数运行前它是一个空列表。
* (4)第二个函数将显示已经打印好的所有设计，它只有一个形参。<br>

1.函数中修改列表<br>
在前一个部分中，程序运行结束后，原列表unprinted_designs将变成一个空列表。<br>
如果我们不想让原列表发生变动，可以使用副本来实现这个操作。<br>
向函数传递原列表的副本而非原件，这样函数进行的操作都只会改变副本，不改变原件。<br>
```
print_models(unprinted_designs[:], completed_models)
```
* (1)使用了切片法[:]来创建副本
* (2)只需要在调用函数时，使用切片法即可
* (3)这种方法效率没有修改副本来的高



